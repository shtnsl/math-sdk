{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Carrot MathEngine","text":""},{"location":"#powered-by-carrotrgs","title":"Powered by CarrotRGS","text":"<p>Welcome to the Carrot-MathEngine! Your one-stop-shop for spectacular slots.</p>"},{"location":"#directory-structure","title":"Directory Structure","text":"<pre><code>src/ \n    calculations/ # Board and Symbol setup, various win-type game logic\n    config/ # Creates configuration files required by the RGS, frontend and optimization algorithm\n    events/ # Data structures passed between math-engine and frontend engine\n    executables/ # Commonly used groupings of game logic and events\n    state/ # Tracks the game-state of all simulations \n    wins/ # Wallet manager handling various win-criteria\n    write_data/ # Handles writing simulation data, compression and force-files\n\ngames/\n    0_0_cluster # Sample cascading cluster-wins game\n    0_0_lines # Basic win-lines example game\n    0_0_ways # Basic ways-wins example game\n    0_0_scatter # Pay-anywhere cascading example game\n    0_0_expwilds # Example of expanding Wild-reel game, with prize-collection feature game\n\ntest/ # [**TBC**] Test cases for various win-types\nutils/ # [**TBC**] Useful functions to aid with file and game analysis\nuplods/ # [**TBC**] Data transformation and upload verification\noptimization/ # [**TBC**] Optimization algorithm\ndocs/ # Markdown files\n</code></pre>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"general_overview/","title":"Setup and installation","text":""},{"location":"general_overview/#installing-the-zuck-enginetm","title":"Installing the Zuck-Engine\u2122","text":"<p>This guide details the recommended process for installing the Carrot-MathEngine and all required packages using the setuptools standard package.</p>"},{"location":"general_overview/#step-1-create-and-activate-a-virtual-environment","title":"Step 1: Create and Activate a Virtual Environment","text":"<p>It's recommended to use a virtual environment to manage dependencies. Using the Virtual Environment manager (venv), install Python version &gt;=3.12 using:</p> <pre><code>python3.12 -m venv venv\n</code></pre> <p>Activate the virtual environment:</p> <ul> <li>Windows:   <pre><code>venv \\scripts \\activate\n</code></pre></li> <li>macOS/Linux:   <pre><code>source venv/bin/activate\n</code></pre></li> </ul>"},{"location":"general_overview/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<p>Use <code>pip</code> to install dependencies from the <code>requirements.txt</code> file:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"general_overview/#step-3-install-the-package-in-editable-mode","title":"Step 3: Install the Package in Editable Mode","text":"<p>Using the <code>setup.py</code> file, the package should be installed it in editable mode (for development purposes) with the command:</p> <pre><code>pip install -e .\n</code></pre> <p>This allows modifications to the package source code to take effect without reinstallation. </p>"},{"location":"general_overview/#step-4-verify-installation","title":"Step 4: Verify Installation","text":"<p>You can check that the package is installed by running:</p> <pre><code>pip list\n</code></pre> <p>or testing the package import in Python:</p> <pre><code>python\n&gt;&gt;&gt; import your_package_name\n</code></pre>"},{"location":"general_overview/#deactivating-the-virtual-environment","title":"Deactivating the Virtual Environment","text":"<p>When finished, deactivate the virtual environment with:</p> <pre><code>deactivate\n</code></pre>"},{"location":"gamestate_section/events_info/","title":"Game Event Structures","text":"<p>Events are the JSON objects returned from the RGS <code>play/</code> API and make up the vast majority of data with a game's library. Events contain all information required by the front-end to display the current state of the game. Anything not contained within or implied by the events cannot be shown to the player. For a typical game this includes, but is not limited to</p> <ul> <li>Active gameboard symbols</li> <li>Freespin counters</li> <li>Win counters</li> <li>Symbol win information</li> <li>Multipliers</li> <li>Special symbol actions </li> <li>....</li> </ul> <p>The events are crucial as all events need to be handled by the front-end. The user is free to determine their event structure, though to follow the example games, all events have the format, <pre><code>    event = {\n        \"index\": [int],\n        \"type\": [str],\n        \"&lt;field_1&gt;\": [T],\n        ...\n        \"&lt;field_n&gt;\": [T]\n    }\n</code></pre> <code>\"index\"</code> keeps track of the current number of events in a simulation, <code>\"type\"</code> is a unique keyword used to identify an event and is generally a one-word description. <code>\"fields\"</code> are strings who's corresponding value can have any data-type, as required. Once constructed, the event is appended to the book, \"events\" field\": <pre><code>    gamestate.book[\"events\"].append(event)\n</code></pre></p> <p>Events are handled separately in the gamestate to game calculations or executables. They are imported explicitly and not attached to the gamestate object. Once the math-engine has made the appropriate board transformation or action, the event should be emitted immediately, as it will provide a snapshot of the current state of the game. For example: <pre><code> from src.Events.Events import update_freespin_event\n run_spin():\n    ...\n    update_freespin_event(self)\n    ....\n</code></pre> These events should be sent anytime new information needs to be communicated to the player.</p>"},{"location":"gamestate_section/force_info/","title":"Custom Defined Events","text":"<p>Every betmode will have a corresponding <code>force_for_rob_&lt;betmode&gt;.json</code>. This file records the <code>book-id</code> corresponding to a custom defined search key. Anytime <code>self.record()</code> is called where <pre><code>    def record(self, description: dict) -&gt; None:\n        self.temp_wins.append(description)\n        self.temp_wins.append(self.book_id)\n</code></pre> The current simulation number will be appended to the description/key if it exists, otherwise a new dictionary entry is made based on the description passed to the <code>record()</code> function. For example, we may want to keep track of how many Scatter symbols caused a freegame trigger. Which will be useful for later analysis to investigate the frequency of any custom defined event. In the freespin trigger executable function for example, <pre><code>    def run_freespin_from_base(self, scatter_key: str = \"scatter\") -&gt; None:\n        self.record(\n            {\n                \"kind\": self.count_special_symbols(scatter_key),\n                \"symbol\": scatter_key,\n                \"gametype\": self.gametype,\n            }\n        )\n        self.update_freespin_amount()\n        self.run_freespin()\n</code></pre> This will ultimately output a <code>force_for_rob_&lt;betmode&gt;.json</code> with the entries: <pre><code>[\n    {\n        \"search\": {\n            \"gametype\": \"basegame\",\n            \"kind\": 5,\n            \"symbol\": \"scatter\"\n        },\n        \"timesTriggered\": 22134,\n        \"bookIds\": [\n            7,\n            12,\n            ....\n        ]\n    },\n    {\n        \"search\": {\n            \"gametype\": \"basegame\",\n            \"kind\": 6,\n            \"symbol\": \"scatter\"\n        },\n        \"timesTriggered\": 1196,\n        \"bookIds\": [\n            9,\n            10\n            ...\n        ]\n    },\n    ...\n]\n</code></pre></p>"},{"location":"gamestate_section/force_info/#summary-force-file","title":"Summary force file","text":"<p>Once all simulations have been completed, a <code>force.json</code> file is produced, which contains all unique search fields and keys. The intended use for this file is for prototyping, where a drop-down menu, or something of the sort can be created for all possible search conditions.</p>"},{"location":"gamestate_section/force_info/#accounting-for-discarded-simulations","title":"Accounting for discarded simulations","text":"<p>The <code>record()</code> function does not directly append the key/book-id to the force file. This action is only performed once a simulation has completed and is accepted. This is to ensure that keys/ids are not prematurely added if a simulation is rejected. Therefore keys and corresponding simulation ids are appended to <code>self.temp_wins</code> and <code>self.temp_wins</code> before being finalized within the <code>imprint_wins()</code> function within <code>src/state/state.py</code>. Keys must be unique, and book-ids are not repeated within keys, though the same book-id may appear within several keys.</p>"},{"location":"gamestate_section/repeat_info/","title":"Simulation Acceptance Criteria","text":"<p>When setting up the game configuration file each mode is split into different win-criteria. Given a total number of simulations for a given bet-mode, the number of simulations required for each criteria is set using a <code>quota</code>, which determines the ratio of the total number of simulations satisfying a particular win criteria. </p> <p>Following the example used in the Sample Games, the win criteria has been split into the following unique conditions:</p> <ol> <li><code>0</code> win amounts</li> <li><code>basegame</code> wins </li> <li><code>freegame</code> scenarios</li> <li><code>max-win</code> scenarios</li> </ol> <p>The purpose of segmenting these game outcomes is to ensure that there are sufficiently many simulations scenarios satisfying a certain criteria. For example if the hit-rate for a max-win is 1% of the avaliable RTP for a game with a 5000x payout would be 1 in 500,000 outcomes. Though if we are only producing 1 Million simulations in total for this mode, we would like to have more than 2 simulations in total which result in the maximum win amount. This reduces the posibility of any players seeing the same outcomes for a specific win amount. </p> <p>In the aforementioned list <code>0</code> dictates that the payout multiplier is ==0 for that simulation number. <code>basegame</code> is essentially any basegame spin where the payout is &gt;0  and the <code>freegame</code> is not triggered. <code>freegame</code> is any scenario where the <code>freegame</code> is triggerd from the basegame. <code>max-win</code> is any outcome where the maximum payout multiplier is awarded.</p> <p>This segmentation of wins is also used by the optimization algorithm.</p> <p>Pertanent to this section though, the simulation acceptance criteria is intergral to the <code>repeat</code> condition implented in all sample games. When the <code>GameState</code> is setup, the acceptance criteria is assigned to a specific simulation number before any simulations are carried out. So simulation 10, for example, is predetermined to be a simulation which triggers a <code>freegame</code>. </p> <p>When the <code>run_spin()</code> function is called and the game-round ends, wheather or not the simulation is recorded and added to the library is partially determined by the final win condition. If the only condition is that the simulation must be a <code>0</code> payout, then the <code>final_win</code> value is checked. If this condition is satisfied the <code>self.repeat = False</code> and the outcome is saved. Likewise if a particular simualation is determined to be <code>freegame</code> criteria, at the end of the spin we verify if the freegame has been triggered and accept the simulation result if so. There can be as many conditions are required in the <code>self.check_repeat()</code> function. Just be aware that the more stringent the criteria, the longer a simulation will likely take to run. This time can be quite substancial if the required criteria is unlikely to be achieved naturally. For the <code>max-win</code> scenarios for example, generally a specificly made reelstrip is used, and the probability if achieving higher multipliers, prizes etc.. is dictated  in the bet-mode distribution.</p>"},{"location":"gamestate_section/repeat_info/#predetermining-acceptance","title":"Predetermining Acceptance","text":"<p>While it would be useful to run the simulations first and then assign the distribution criteria afterwards, this can cause issues when multi-threading larger simulation batches. Simulations relating to max-wins for example typically take substancially longer to succede than say <code>0</code> win simulations. This means that all crietria except the max-win are likely to be filled first, leaving the final thread to deal with many or all of the max-win simulations. For this reason, the <code>quota</code> in the BetMode distribution conditions is used in conjunction with the total number of simulations. </p>"},{"location":"gamestate_section/win_info/","title":"Win calculations","text":"<p>There are several built-in win methods included in the engine:</p> <ol> <li>Lines pays</li> <li>Ways pays</li> <li>Cluster pays</li> <li>Scatter pays</li> </ol>"},{"location":"gamestate_section/win_info/#_1","title":"Wins","text":"<p>Irrespective of the win method applied, win information is stored in the gamestate object win_data: <pre><code> win_data = {\n    'totalWin': [float],\n    'wins': [List[Dict]]\n }\n</code></pre> This initialized <code>win_data</code> structure is the return value for all provided win calculation functions. If using the predefined win events, the dictionary items within <code>wins</code> must contain the \"position\" key to account for modifying the row number if needed for the padding symbols. All wins information for the current game board should be included in this structure. Such as all winning symbol combinations, win amounts and positions. The built-in functions also include a <code>meta' key which includes any additional information which the front-end may need to display. For the win-lines, as an example this appears as: <pre><code>...\n'wins': {\n    'symbol': 'H1',\n    'kind': 5,\n    'win': 300,\n    'positions': [{'reel':1, 'row':1}, ...],\n    'meta':{\n        'lineIndex': 12,\n        'multiplier': 10,\n        'winWithoutMult': 30,\n        'globalMult': 1,\n        'lineMultiplier': 10\n    }\n}\n</code></pre> This additional information includes any symbol or global multiplier values applied, the base win amount, and the</code>lineIndex`, as defined in config.paylines = {[], ...}``</p>"},{"location":"gamestate_section/win_info/#multiplier-methods","title":"Multiplier methods","text":"<p>For generality all win methods inherit functions from the <code>MultiplierStrategy</code> class. By calling <code>apply_mult()</code> with a specified strategy (<code>global</code>, <code>symbol</code>, <code>combined</code>), base win amount and winning symbol positions, total win amounts are returned inclusive of any global multipliers or symbol multipliers. By default, if the <code>combined</code> or <code>symbol</code> strategy is used, multiplier values are added together from winning symbol positions, where the symbol object contains the <code>multiplier</code> attribute.</p>"},{"location":"gamestate_section/win_info/#overlay-values","title":"Overlay values","text":"<p>The cluster and scatter pay sample games, there is an <code>overlay</code> key included ine <code>win_data</code> \"meta\" tag of the structure: <pre><code>'meta': {\n    ...\n    'overlay': {'reel': [int], 'row': [int]}\n}\n</code></pre> This position is calculated as the board position closest to the  centre-of-mass of winning clusters.</p>"},{"location":"gamestate_section/win_info/#wallet-manager","title":"Wallet manager","text":"<p>When writing game logic, the intent is to have a clear seperation of logic, events and wins for clarity. The wins are all handled through a <code>WalletManager</code> class, which will handle outcomes from single spins while also keeping track of total cumulative win amount for RTP calculations, as well as which gametype the wins arise from.</p> <p>This can be seen in a typical gamestate <code>run_spin()</code> function where wins are calculated, the wallet is updated and corresponding win events are emitted: <pre><code>self.win_data = self.get_lines()\nself.win_manager.update_spinwin(self.win_data[\"totalWin\"])\nself.emit_linewin_events()\n</code></pre></p> <p>Within a single spin there are wallet manager values associed with:</p> <ol> <li><code>spin_win</code> <ul> <li>This is the win associated with a specific <code>reveal</code> event. If the freegame is entered, this value is reset for each new spin. </li> <li>Updated using <code>wallet_manager.update_spinwin(win_amount: float)</code></li> </ul> </li> <li><code>running_bet_win</code><ul> <li>This is the cumulative win amount for a simulation. The final value which the <code>running_bet_win</code> is updated with should match the <code>payout_multiplier</code> for that simuation. </li> <li>This value is automatically updated with the <code>wallet_manager.set_spinwin(win_amount: float)</code> method.</li> </ul> </li> <li><code>basegame_wins</code>/<code>freegame_wins</code><ul> <li>This value is updated once all basegame actions are completed, or at the end of each freegame spin.</li> <li>Updated using <code>wallet_manager.update_gametype_wins(self.gametype)</code></li> <li>Important! As part of the final payout verification self.final_win and sum(self.basegame_wins + self.freegame_wins) must match. If these two payouts do not match a <code>RuntimeError</code> is raised. </li> <li>This is useful for game analysis and applying the correct parameters to the optimization algorithm. </li> </ul> </li> <li>Cumulative simulation wins<ul> <li><code>total_cumulative_wins</code>, <code>cumulative_base_wins</code> and <code>cumulative_free_wins</code> wins are updated at the end of each simulation. This value is used to display the runtime RTP for all simulations when printed in the terminal.</li> <li>Updated using <code>wallet_manager.update_end_round_wins()</code> within the <code>imprint_wins</code> function.</li> </ul> </li> </ol>"},{"location":"gamestate_section/configuration_section/betmode_dist/","title":"Distribution Conditions","text":"<p>Within each <code>BetMode</code> there is a set of <code>Distribution</code> Classes which determine the win-criteria within each bet-mode. Required fields are:</p> <ol> <li>Criteria<ul> <li>A shorthand name describing the win condition in a single word</li> </ul> </li> <li>Quota<ul> <li>This is the amount of simulations (as a ratio of the total number of bet-mode simulation) which need to satisfy the corresponding criteria. The quota is normalised when assigning criteria to simulations, so the sum of all quotas does not need to be 1. There is a minimum of 1 simulation assigned per criteria.</li> </ul> </li> <li> <p>Conditions</p> <ul> <li>Conditions can have an arbitary number of keys. Though the required keys are:<ul> <li><code>reel_weights</code> </li> <li><code>force_wincap</code></li> <li><code>force_freespins</code></li> </ul> </li> </ul> <p>Note that <code>force_wincap</code> and <code>force_freespins</code> are set to <code>False</code> by default and do not have to be explicitly added.</p> <p>The most common use for the Distribution Conditions is when drawing a random value using the BetMode's built-in method <code>get_distribution_conditions()</code>. i.e. <pre><code>    multiplplier = get_random_outcome(betmode.get_distribution_conditions()['mult_values'])\n</code></pre> Or to check if a board forcing the <code>freegame</code> should be drawn with: <pre><code>if get_distribution_conditions()['force_freespins']:\n    ...\n</code></pre></p> </li> <li> <p>Win criteria (optional)</p> <p>There is also a <code>win_criteria</code> condition which incorporates a payout multiplier into the simulation acceptance. The two commonly used condtions are <code>win_criteria = 0.0</code> and <code>win_criteria = self.wincap</code>. When calling <code>self.check_repeat()</code> at the end of a simulation, if <code>win_criteria</code> is not <code>None</code> (default), the final win amount must match the value passed. </p> <p>The intention behind betmode distribution conditions is to give the option to handle game actions in a way which depends on the (known) expected simulation. This is most clear if for example a simulation is known to correspond to a <code>max-win</code> scenario. Instead of repeatly drawing random outcomes which are most likely to be rejected, we can alter the probabilties of larger payouts occurring by biasing a particular reelset, weighting larger prize or multiplier values etc..</p> </li> </ol>"},{"location":"gamestate_section/configuration_section/betmode_overview/","title":"BetMode","text":"<p>All valid bet-modes are defined in the array <code>self.bet_modes = [ ...]</code>  The <code>BetMode</code> class is an important configuration for when setting up game the behaviour of a game. A full description of all features is defined here</p> <p>This class is used to set maximum win amounts, RTP, bet cost, and distribution conditions. Additional noteworthy tags are:</p> <ol> <li><code>auto_close_disabled</code><ul> <li>When this flag is <code>False</code> (default) the RGS endpoint API <code>/endround</code> is called automatically to close out the bet for efficiency. When the bet is closed however, the player cannot resume their bet. It may be desirable in bonus modes for example, to set this flag to <code>True</code> so that the player can resume interrupted play even if the payout is <code>0</code>. This means that the front-end will have to manually close out the bet in this instance.</li> </ul> </li> <li><code>is_feature</code><ul> <li>When this flag is true, it tells the frontend to preserve the current bet-mode without the need for player interaction. So if the player changes to <code>alt_mode</code> where this mode has <code>is_feature = True</code>, every time the spin/bet button is pressed, it will call the last selected bet-mode. Unlike in bonus games, where the player needs to confirm the bet-mode choice after each round completion.</li> </ul> </li> <li><code>is_buybonus</code><ul> <li>This is a flag used for the frontend framework to determine if the mode has been purchased directly (and hence may require a change in assets).</li> </ul> </li> </ol>"},{"location":"gamestate_section/configuration_section/config_overview/","title":"Game Configuration Files","text":"<p>The GameState object requires certain parameters to be specified, and should be manually filled out for each new game. These elements are all defined in the <code>__init__</code> function. Full details of the expected inputs and data-types are given in the Source Files/Config section. </p> <p>General aspects of the game setup which should be considered when creating a <code>game_config.py</code> are:</p>"},{"location":"gamestate_section/configuration_section/config_overview/#gametypes","title":"Gametypes","text":"<p>Several parts of the engine such as win amount verification, special symbol triggers/attributes and win-levels require the engine to know if the current state of the game is in the basegame or freegame. For example it is common to perform a weighted draw of some value:  <pre><code>#Within game config:\nself.multiplier_values = {\n   \"basegame\":{1:100, 2:50, 3: 10}, \n   \"freegame\":{2:20, 3:50, 5: 20, 10:10, 20:1}}\n....\n#Within gamestate:\nmultiplier = get_random_outcome(self.config.multiplier_values[self.gametype])\n</code></pre> Typically special rules apply when the player enters a freegame. The configuration file allows the user to specify the key corresponding to each gametype. By default this is set to <code>basegame</code> and <code>freegame</code> respectively. All simulations will start in the basegame mode unless otherwise specified, and the transition to the freegame state is handled in the default <code>reset_fs_spin()</code> function, which is called as soon as the <code>run_freespin()</code> function is entered. </p>"},{"location":"gamestate_section/configuration_section/config_overview/#path-construction","title":"Path construction","text":"<p>When simulation results are saved, there are several files which are saved upon completing the simulation, along with the path to reel-strips the existence of the following output files are verified, and created if they do not exist. These paths can be checked by accessing self.config.&lt; path_label &gt;</p> <ul> <li>library_path: <code>games/game_id/library/</code></li> <li>books_path/books_compressed_path: <code>games/game_id/library/books/</code></li> <li>lookup_path: <code>games/game_id/library/lookup_tables/</code></li> <li>config_path: <code>games/game_id/library/configs/</code></li> <li>force_path: <code>games/game_id/library/forces</code></li> <li>temp_path: <code>games/game_id/library/temp_multi_threaded_files/</code></li> <li>reels_path: <code>games/game_id/reels/</code></li> </ul>"},{"location":"gamestate_section/configuration_section/config_overview/#reels","title":"Reels","text":"<p>Most games will use distinct reelstrips for different gametypes. It is commonplace for game-modes to have multiple possible reels per mode. One method of adjusting the overall RTP of a game is to have a multiple reelstrips with varying RTP, which can be selected from a weighted draw when calling <code>self.create_board_from_reelstrips()</code>. Reelstrips are stored as a dictionary in the <code>self.config.reels</code> object. The reelstrip key and csv file name should be specified: <pre><code>        reels = {\"BR0\": \"BR0.csv\", \"FR0\": \"FR0.csv\"}\n        self.reels = {}\n        for r, f in reels.items():\n            self.reels[r] = self.read_reels_csv(str.join(\"/\", [self.reels_path, f]))\n</code></pre> Reelstrip weightings are required distribution conditions. An example of using multiple reelstrips for each gametype can be applied as: <pre><code>    conditions={\n        \"reel_weights\": {self.basegame_type: {\"BR0\": 2, \"BR1\": 1}, self.freegame_type: {\"FR0\":5, \"FR1\": 1}},\n    },\n</code></pre></p>"},{"location":"gamestate_section/configuration_section/config_overview/#scatter-triggers-and-anticipation","title":"Scatter triggers and Anticipation","text":"<p>Freegame entry from the basegame or retriggers in the freegame should be specified in the format <code>{num_scatters: num_spins}</code>, <pre><code>    self.freespin_triggers = {\n        self.basegame_type: {3: 10, 4: 15, 5: 20},\n        self.freegame_type: {2: 4, 3: 6, 4: 8, 5: 10},\n    }\n</code></pre></p>"},{"location":"gamestate_section/configuration_section/config_overview/#symbol-initialization","title":"Symbol initialization","text":"<p>A symbol is determined to be valid if the name exists either in <code>self.paytable</code> or in <code>self.special_symbols</code>. If a symbol that does not exist in either of these fields is detected when loading reelstrips, a <code>RuntimeError</code> is raised.</p>"},{"location":"gamestate_section/configuration_section/config_overview/#symbol-values","title":"Symbol values","text":"<p>Winning symbols are determined from the <code>self.paytable</code> dictionary object in the game configuration. The expected format is: <pre><code>    self.paytable = {\n        (kind[int], name[str]): value[float],\n        ...\n    }\n</code></pre> Where <code>kind</code> is the number of winning symbols. For cascading games, or other circumstances where multiple winning symbol numbers pay the same about, for example in the scatter pays example game where 13+ symbols pay the same amount, <code>self.pay_group</code> can be defined. By then calling <code>self.paytable = self.convert_range_table(pay_group)</code> a paytable of the expected format is generated. The format of the pay-group objects (inclusive of both values in the kind-range) is given as: <pre><code>    self.pay_group = {\n        ((min_kind[int],max_kind[int]), name[str]): value[float],\n        ...\n    }\n</code></pre></p>"},{"location":"gamestate_section/configuration_section/config_overview/#special-symbols","title":"Special symbols","text":"<p>Special symbol attributes are assigned based on names appearing in <code>self.special_symbols = {attribute[str]: [name[str], ...]}</code>. Multiple symbols can share attributes and multiple attributes can be applied to the same symbol. Most games will at least have a <code>wild</code> and <code>scatter</code> attribute. Once the symbol is initialised, the value of the attribute is accessed through <code>symbol.attribute</code> or symbol.get_attribute(attribute) see Symbols for more information regarding symbol object structures. By default the attribute is set to <code>True</code>, unless otherwise overridden using the <code>gamestate.special_symbol_functions</code>, defined in the gamestate override.</p>"},{"location":"gamestate_section/syms_board_section/board_info/","title":"Active Game Board","text":"<p>The active game-board is created as a 2D array of symbol objects. Each object within the array creates a new object instance. </p>"},{"location":"gamestate_section/syms_board_section/board_info/#displaying-the-board","title":"Displaying the board","text":"<p>The board can be displayed by calling the <code>print_board()</code> method in the <code>Board</code> class, which will display a correctly orientated printout of all symbol names <pre><code>self.print_board(self.board) -&gt;\n</code></pre> <pre><code>L5 L3 L4 L4 L4 \nL3 H4 L3 H1 L4 \nL3 H1 S  L3 H1 \n</code></pre></p>"},{"location":"gamestate_section/syms_board_section/board_info/#active-special-symbols","title":"Active special symbols","text":"<p>When the game board is generated any symbols appearing in <code>config.special_symbols = {'property' : [symbols, ..]}</code> will be appended to the gamestate property <code>special_symbols_on_board = {'property': [{'reel': reel[int], 'row': row[int]}]}</code>. This property is particularly useful for checking aspects such as freegame entry conditions: <pre><code>    if len(self.special_symbols_on_board['scatter']) &gt;= min_scatter:\n        self.run_freespin_from_base()\n</code></pre></p> <p>Care should be taken to update any new symbols which may appear on the board either from cascading events or through the application of some special action, such as removing symbols from the game board. If custom functions are being used which involve altering active symbols, the method <code>get_special_symbols_on_board()</code> from the <code>Board</code> class should be invoked.</p>"},{"location":"gamestate_section/syms_board_section/board_info/#tumbling-the-board","title":"Tumbling the board","text":"<p>For cascading games (such as the Scatter and Cluster example games), winning symbols are removed from the board and symbols above tumble down to fill these vacant positions. Winning symbols are assigned the attribute <code>explode</code>. Subsequently when the <code>tumble_board()</code> method is called from the <code>Tumble</code> class, </p>"},{"location":"gamestate_section/syms_board_section/board_info/#topbottom-symbols","title":"Top/bottom symbols","text":"<p>In the <code>config</code> class, there is a boolean option <code>include_padding</code>. This is to account for games where it is desirable for the player to see the symbols immediately above/below the active board. Usually this is displayed as a symbol being partially in-frame. If this flag is set to true, the row indexing for the active game board will start at <code>row=1</code>, where <code>row 0</code> is the <code>top_symbol</code> and <code>row len(board) + 1</code> is the <code>bottom_symbol</code>. The top and bottom symbols are included in the <code>board</code> <code>reveal</code> event. Within the gamestate these symbols are stored as: <pre><code>self.top_symbols = [s1, s2, ....]\nself.bottom_symbols = [s1, s2, ....]\n</code></pre> Note that for cascading/tumbling games, the top symbol is preserved during the tumble.</p>"},{"location":"gamestate_section/syms_board_section/symbol_info/","title":"Symbol structure","text":"<p>Symbols are handled as their own distinct class objects. Based only off a symbol name, several useful attibutes are assigned to the object based on if the symbol name appears in in the <code>config.paytable</code> or <code>config.special_symbols</code> fields. </p> <p><pre><code>class Symbol:\n    def __init__(self, config: object, name: str) -&gt; None:\n        self.name = name\n        self.special_functions = []\n        self.special = False\n        is_special = False\n        for special_property in config.special_symbols.keys():\n            if name in config.special_symbols[special_property]:\n                setattr(self, special_property, True)\n                is_special = True\n\n        if is_special:\n            setattr(self, \"special\", True)\n\n        self.assign_paying_bool(config)\n</code></pre> When a new game-board is drawn, a 2D array of symbol objects are generated. At a minimum, the symbol will have the attributes:</p> <ol> <li>Name<ul> <li>[string] shorthand name, typically 1 or 2 letters</li> </ul> </li> <li>special_functions<ul> <li>Within the <code>GameStateOverride</code> class, special functions can be applied to a symbol as soon as the object is created. This is done through the abstract function, for example: <pre><code>    def assign_special_sym_function(self):\n        self.special_symbol_functions = {\n            \"W\": [self.assign_mult_property],\n        }\n    def assign_mult_property(self, symbol):\n        multiplier_value = get_random_outcome(\n            self.get_current_distribution_conditions()[\"mult_values\"][self.gametype]\n        )\n        symbol.assign_attribute({\"multiplier\": multiplier_value})\n</code></pre> <code>assign_special_sym_function()</code> is called when the <code>GameState</code> is initially created. In this example, we are assigning a multiplier value to any new wild ('W') which is created. Any action defined within <code>self.special_symbol_functions</code> with the format <code>{&lt;name&gt;: @callable_func}</code> will be assigned to the <code>special_functions</code> property.</li> </ul> </li> <li>is_special<ul> <li>This property is assigned as <code>False</code> by default unless the name appears as a value within <code>config.special_symbols</code></li> </ul> </li> <li>special_property<ul> <li>Properties appearing in <code>config.special_functions = {'property': [name]}</code> are set to <code>True</code> by default. </li> </ul> </li> <li><code>assign_paying_bool</code><ul> <li>This function assigns the properties <code>is_paying</code> and <code>paytable</code>. If the symbol name appears in <code>config.paytable</code> <code>is_paying</code> is set to <code>True</code> and the relevant paytable values are assigned to <code>paytable</code>. Otherwise these values are set to <code>False</code> and <code>None</code> respectively.</li> </ul> </li> </ol>"},{"location":"gamestate_section/syms_board_section/symbol_info/#symbol-attributes","title":"Symbol Attributes","text":"<p>In addition to the application of <code>special_functions</code>, attributes are an important characteristic of symbol objects, particularly for checking if there are any special symbols on the game-board which require additional actions. For example if we want to check if a given symbol has a <code>prize</code> or <code>multiplier</code> attribute: <pre><code>    if self.board[reel][row].check_attribute('prize','multiplier'):\n        ...\n</code></pre></p> <p>The <code>check_attribute</code> function will return a <code>boolean</code> value if the given attribute exists and its value is not <code>False</code>. I.e.: <pre><code>    if symbol.check_attribute('prize'):\n        win += symbol.get_attribute('prize')\n</code></pre></p> <p>Furthermore we can assign properties to a symbol using the <code>assign_attribute</code> method. As an example, if we have a game where we have a special symbol denoted by the <code>enhance</code> tag. Where the effect of this symbol is to add a <code>multiplier</code> value to any active <code>Wild</code> symbols. In the <code>gamestate</code> we could preform the following actions: <pre><code>    if len(self.special_symbols_on_board['enhance']) &gt; 0:\n        for sym in self.special_symbols_on_board[wild]:\n            mult_val = get_random_outcomes(self.config.mult_values[self.gametype])\n            self.board[sym['reel']][sym['row']].assign_attribute({'multiplier', mult_val})\n</code></pre></p>"},{"location":"overview_section/game_format/","title":"Standard Game Setup Requirements","text":"<p>Without diving into specific functions, this section is intended to walkthrough how a new slot game would generally be setup. In practice it is recommended to start with one of the sample games which closest resemble the game being made, or otherwise starting from the template.</p>"},{"location":"overview_section/game_format/#configuration-file","title":"Configuration file","text":"<p>Game parameters should all be set in the <code>GameConfig</code> <code>__init__()</code> function. This is where to set the name name, RTP, board dimensions, payouts, reels and various special symbol actions. All required fields are listed in the <code>Config</code> class and should be filed out explicitly for each new game. Next the <code>BetMode</code> classes are defined. Generally there would be at a minimum a (default) <code>base</code> game and a <code>freegame</code>, which is usually purchased. </p> <pre><code>class GameConfig(Config):\n    def __init__(self):\n        super().__init__()\n        self.game_id = \"\"\n        self.provider_number = 0\n        self.working_name = \"\"\n        self.wincap = 0\n        self.win_type = \"lines\"\n        self.rtp = 0\n\n        self.num_reels = 0\n        self.num_rows = [0] * self.num_reels  \n        self.paytable = {\n            (kind, symbol): payout, \n        }\n\n        self.include_padding = True\n        self.special_symbols = {\"property\": [\"sym_name\"],...}\n\n        self.freespin_triggers = {\n        }\n        self.reels = {}\n        self.bet_modes = []\n</code></pre> <p>Each <code>BetMode</code> should likewise be set explicitly, defining the cost, rtp maximum win amounts and various gametype flags. We would like to define different win criteria within each betmode. In the sample games we define distinct criteria for any game-aspects where we would like to control either the hit-rate and/or RTP allocation. In this example we would like to control the basegame hit-rate, max-win hit-rate and freegame hit-rate. Therefore we need to specify unique <code>Distribution</code> criteria for each of these special conditions. Further information about purpose of Distribution conditions can be found here and here <pre><code>    BetMode(\n        name=\"base\",\n        cost=1.0,\n        rtp=self.rtp,\n        max_win=self.wincap,\n        auto_close_disabled=False,\n        is_feature=True,\n        is_buybonus=False,\n        distributions=[\n            Distribution(\n                criteria=\"winCap\",\n                quota=0.001,\n                win_criteria=self.wincap,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"force_wincap\": True,\n                    \"force_freespins\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"freegame\",\n                quota=0.1,\n                conditions={\n                    \"reel_weights\": {\n                        self.basegame_type: {\"BR0\": 1},\n                        self.freegame_type: {\"FR0\": 1},\n                    },\n                    \"force_wincap\": False,\n                    \"force_freespins\": True,\n                },\n            ),\n            Distribution(\n                criteria=\"0\",\n                quota=0.4,\n                win_criteria=0.0,\n                conditions={\n                    \"reel_weights\": {self.basegame_type: {\"BR0\": 1}},\n                },\n            ),\n            Distribution(\n                criteria=\"basegame\",\n                quota=0.5,\n                conditions={\n                    \"reel_weights\": {self.basegame_type: {\"BR0\": 1}},\n                },\n            ),\n        ],\n    )\n</code></pre></p>"},{"location":"overview_section/game_format/#gamestate-file","title":"Gamestate file","text":"<p>When any simulation is run, the entry point will be the <code>run_spin()</code> function, which lives in the <code>GameState</code> class. <code>GameExecuatables</code> and <code>GameCalculations</code> are child classes of <code>GameState</code> and also deal with game specific logic and are discussed separately in the Gamestate Section</p> <p>The generic structure would follow the format: <pre><code>def run_spin(self, sim):\n    self.reset_seed(sim) #seed the RNG with the simulation number \n    self.repeat = True\n    while self.repeat:\n        self.reset_book() #reset local variables\n        self.draw_board() #rraw board from reelstrips\n\n        #evaluate win_data\n        #update win_manager\n        #emit relevant events\n\n        self.win_manager.update_gametype_wins(self.gametype) #update cumulative basegame wins\n        if self.check_fs_condition(): #check scatter conditions\n            self.run_freespin_from_base() #run freegame\n\n        self.evaluate_finalwin()\n        self.check_repeat() #Verify betmode distribution conditions are satisfied\n\n    self.imprint_wins() #save simulation result\n</code></pre></p> <p>For reproducibility the RNG is seeded with the simulation number. Betmode distribution criteria are preassigned to each simulation number, requiring the <code>self.repeat</code> condition to be initially set until the spin has completed and it can be checked that any criteria-specific conditions or win amounts are satisfied. Note that <code>self.repeat = False</code> is set in the <code>self.reset_book()</code> function. This function will reset all relevant <code>GameState</code> properties to default values. </p> <p>Generally the first steps will be to use the reelstrips provided in the configuration file to draw a board from randomly chosen reelstop positions. Wins are evaluated from one of the provided win-types for the active board, and the wallet manager is updated. After this game-logic is completed the relevent events (such as <code>reveal</code> and <code>winInfo</code>) are emitted. All sample games follow these three steps: 1. Calculate current state of the board 2. Update wallet manager 3. Emit events</p> <p>To keep track of which gametype wins are allocated, the wallet manger is again invoked once all basegame actions are complete. If the game have a freegame mode and the triggering conditions are satisfied the <code>run_freespin()</code> function is invoked. This mode will have a similar structure: <pre><code>def run_freespin(self):\n    self.reset_fs_spin() #reset freegame variables\n    while self.fs &lt; self.tot_fs: #account for multiple freegame spins\n        self.update_freespin() #update spin number and emit event\n        self.draw_board() #draw a new board using freegame reelstrips\n\n        #evaluate win_data\n        #update win_manager\n        #emit relevant events\n\n        if self.check_fs_condition(): #check retrigger conditions\n            self.update_fs_retrigger_amt()\n\n        self.win_manager.update_gametype_wins(self.gametype) #update cumulative freegame win amounts\n\n    self.end_freespin() #emit event to indicate end of freegame\n</code></pre></p> <p>While it is possible to perform all game actions within these functions, for clarity functions from <code>GameExecutables</code> and <code>GameCalculations</code> are typically invoked and should be created on a game-by-game basis depending on requirements. </p>"},{"location":"overview_section/game_format/#runfile","title":"Runfile","text":"<p>Finally to produce simulations, the <code>run.py</code> file is used to create simulation outputs and config files containing game and simulation details.  <pre><code>if __name__ == \"__main__\":\n\n    num_threads = 1\n    rust_threaeds = 20\n    batching_size = 50000\n    compression = False\n    profiling = False\n\n    num_sim_args = {\n        \"base\": int(10),\n        \"bonus\": int(10),\n    }\n\n    config = GameConfig()\n    gamestate = GameState(config)\n\n    create_books(\n        gamestate,\n        config,\n        num_sim_args,\n        batching_size,\n        num_threads,\n        compression,\n        profiling,\n    )\n    generate_configs(gamestate)\n</code></pre> The <code>create_books</code> function handles the allocation of win criteria to simulation numbers, output file format and multi-threading parameters. </p>"},{"location":"overview_section/game_format/#outputs","title":"Outputs","text":"<p>Simulation outputs are placed in the <code>game/library/</code> folder. <code>books/books_compressed</code> is the primary data-file containing all events and payout multipliers. <code>lookup_tables</code> hold the summary simulation-payout values in <code>.csv</code> format which is consumed by the optimization algorithm. Additionally for game analysis, lookup table mapping of which simulations belong to which win criteria and which gametype wins arise from are produced. <code>force/</code> file outputs contain all information used by the <code>.record()</code> function, which is again useful for analyzing the frequency and average win amounts for specific events. The optimization algorithm also uses the recorded <code>force</code> data to identify which simulations correspond to specific win criteria. Finally <code>config/</code> files contain information required by the frontend such as symbol and betmode information, backend information such as file hash values and a configuration file for the optimization algorithm.</p>"},{"location":"overview_section/game_struct/","title":"Intended Engine Usage","text":""},{"location":"overview_section/game_struct/#game-files","title":"Game Files","text":"<p>As seen in the example games, all games follow a recommended structure, which should be copied from the games/template folder. </p> <pre><code>```\ngame/\n\u251c\u2500\u2500 library/\n|----- books/\n|----- books_compressed/\n|----- configs/\n|----- forces/\n|----- lookup_tables/\n\u251c\u2500\u2500 reels/\n\u251c\u2500\u2500 readme.txt\n\u251c\u2500\u2500 run.py\n\u251c\u2500\u2500 game_config.py\n\u251c\u2500\u2500 game_executables.py\n\u251c\u2500\u2500 game_calculations.py\n\u251c\u2500\u2500 game_events.py\n\u251c\u2500\u2500 game_override.py\n\u2514\u2500\u2500 gamestate.py\n```\n</code></pre> <p>Sub-folders within library/ are automatically generated if they do not exist at the completion of the simulation. readme.txt is used for developer descriptions of game mechanics and miscellenous information relevant to that particular game.</p> <p>While all commonly used engine functions are handled by classes within their respective src/ directory, every game is likely to be unique in some way and these game-files allow the user to override existing functions in order to add additional engine features to suit their use-case, or implement game-specific logic. </p> <p>The game_config/executables/calculations/events/override files offer extensions on actions defined in the Source Files section, which should be consulted for more detailed information.</p>"},{"location":"overview_section/game_struct/#run-file","title":"Run-file","text":"<p>This file is used to set simulation parameters, specifically the configuration and <code>GameState</code> classes. The required specifications include:</p> Parameter Type Description <code>num_threads</code> <code>int</code> Number of threads used for multithreading <code>rust_threads</code> <code>int</code> Number of threads used by the Rust compiler <code>batching_size</code> <code>int</code> Number of simulations run on each thread <code>compression</code> <code>bool</code> <code>True</code> for <code>.json.zst</code> compressed books, <code>False</code> for <code>.json</code> format <code>profiling</code> <code>bool</code> <code>True</code> outputs and opens a <code>.svg</code> flame graph <code>num_sim_args</code> <code>dict[int]</code> Keys must match bet mode names in the game configuration <p>All simulations are passed to the <code>create_books()</code> function which carries out all the simulations and handles file output. This function will populate <code>library/</code> <code>books_compressed</code>, <code>books</code>, <code>forces</code>,  <code>lookup_tables</code> folders.</p> <p>Once the simulations are completed, the gamestate is passed to <code>generate_configs(gamestate)</code> which handles generating config files used for the frontend (<code>config_fe.json</code>), backend (<code>config.json</code>) and optimization (<code>config_math.json</code>). </p>"},{"location":"overview_section/game_struct/#library-folders","title":"Library Folders","text":""},{"location":"overview_section/game_struct/#booksbooks_compressed","title":"books/books_compressed","text":"<p>Depending on the compression tag passed to <code>create_books()</code> the <code>books/</code> or <code>books_compressed/</code> folders will be populated with the events emitted from the simulation. </p>"},{"location":"overview_section/game_struct/#configs","title":"configs","text":"<p>This will consist of three <code>.json</code> files for the math, frontend and backend. The details of which are described here.</p>"},{"location":"overview_section/game_struct/#lookup_tables","title":"lookup_tables","text":"<p>Once any given simulation is compete the events associated are stored within the books, and the corresponding payout details are recorded in a lookup table of the format:</p> Simulation Weight Payout <code>int</code> <code>int</code> <code>float</code> <p>All simulations start with an assigned weight of <code>1</code>, which is then modified if the optimization algorithm is applied. </p>"},{"location":"overview_section/game_struct/#configs_1","title":"Configs","text":"<p>The GameConfig inherits the Config class. All information defined in the init function are required inputs. Symbol information, pay-tables, reels-strips and bet-mode information are all specified here. </p>"},{"location":"overview_section/game_struct/#gamestate","title":"Gamestate","text":"<p>Every game has a gamestate.py file, where independent simulation states are handled. The run_spin() function is required and used as the entry_point from create_books to execute the a single simulation. run_freespin is also used in all sample games, though is not a required function if the game does not contain a free-spin entry from the base-game.</p>"},{"location":"overview_section/game_struct/#executables","title":"Executables","text":"<p>Commonly used groups of game-logic and event emission is provided in this location. Functions called in the run_spin() functions will typically belong to the Executables/GameExecutables classes. </p> <p>Functions currently in this class include drawing random or forced game-boards, handling game-logic for several win-types and their associated win information events, updating and </p>"},{"location":"overview_section/game_struct/#misc-calculations","title":"Misc. Calculations","text":"<p>The Executables class inherits all miscellaneous game-logic and board-actions. Primarily this includes all win-evaluation types:  * Lines  * Ways  * Scatter (pay anywhere)  * Cluster </p> <p>Additionally other classes attached to Executables are tumbling/cascading of winning symbols and Conditions for checking the current simulation state</p>"},{"location":"overview_section/state_overview/","title":"The State Machine","text":""},{"location":"overview_section/state_overview/#introduction","title":"Introduction","text":"<p>When initializing a simulation batch, the GameState class serves as a central hub that manages all simulation aspects, including:</p> <ul> <li>Simulation parameters</li> <li>All game modes</li> <li>Configuration settings</li> <li>Simulation results</li> <li>Output files</li> </ul> <p>This class acts as a super-class, ensuring shared components across all simulations. The entry point for all game simulations is the <code>run.py</code> file, which sets up parameters through the Config class and initializes a GameState object. The GameState handles crucial aspects such as:</p>"},{"location":"overview_section/state_overview/#simulation-configuration","title":"Simulation Configuration","text":"<ul> <li>Compression</li> <li>Tracing</li> <li>Multithreading</li> <li>Output files</li> <li>Cumulative wins</li> </ul>"},{"location":"overview_section/state_overview/#game-configuration","title":"Game Configuration","text":"<ul> <li>Bet modes</li> <li>Paytable</li> <li>Symbols</li> <li>Reelsets</li> </ul> <p>These global <code>GameState</code> attributes remain consistent across all games, modes, and simulations. When a simulation runs, <code>run_spin()</code> creates a sub-instance of the General GameState, allowing modifications to game data through the <code>self</code> object.</p>"},{"location":"overview_section/state_overview/#example-simulation-execution","title":"Example Simulation Execution","text":"<p>When a simulation is executed, key game events modify the state:</p> <pre><code>self.draw_board()\nwin_data = self.get_lines()\nself.emit_linewin_events()\n</code></pre> <ul> <li><code>self.draw_board()</code>: Generates a random board state.</li> <li><code>self.get_lines()</code>: Evaluates winning paylines.</li> <li><code>self.emit_linewin_events()</code>: Triggers game events based on results.</li> </ul> <p>For a deeper dive into executables and state modifications, see GameState. The central idea is that the GameState represents the current state of the simulation. And components within this state are modified directly. This reduces the need to be passing objects back and forth between functions when writing game logic.</p>"},{"location":"overview_section/state_overview/#class-inheritance","title":"Class Inheritance","text":""},{"location":"overview_section/state_overview/#why-use-class-inheritance","title":"Why Use Class Inheritance?","text":"<p>Class inheritance ensures flexibility, allowing developers to access core functions while customizing specific behaviors for each game. Core functions are found in the Source Files section and can be overridden at the game level.</p>"},{"location":"overview_section/state_overview/#gamestateoverride-gamegame_overridepy","title":"GameStateOverride (game/game_override.py)","text":"<p>This class is the first in the Method Resolution Order (MRO) and is responsible for modifying or extending actions from the <code>state.py</code> file. All sample games override the <code>reset_book()</code> function to accommodate game-specific parameters.</p> <p>Example: <pre><code>def reset_book(self):\n    super().reset_book()\n    self.reset_grid_mults()\n    self.reset_grid_bool()\n    self.tumble_win = 0\n</code></pre></p> <p>Each game has unique rules, such as cluster multipliers or cascading wins, which are set here.</p>"},{"location":"overview_section/state_overview/#gameexecutables-gamegame_executablespy","title":"GameExecutables (game/game_executables.py)","text":"<p>Executable functions group multiple game actions together. These functions can be overridden to introduce new mechanics at the game level.</p> <p>Example: Updating free spins based on Scatters: <pre><code>def update_freespin_amount(self, scatter_key: str = \"scatter\"):\n    self.tot_fs = self.count_special_symbols(scatter_key) * 2\n    fs_trigger_event(self, basegame_trigger=basegame_trigger, freegame_trigger=freegame_trigger)\n</code></pre></p>"},{"location":"overview_section/state_overview/#gamecalculations-gamesgame_calculationspy","title":"GameCalculations (games/game_calculations.py)","text":"<p>This class handles game-specific calculations, inheriting from GameExecutables.</p>"},{"location":"overview_section/state_overview/#books-and-libraries","title":"Books and Libraries","text":""},{"location":"overview_section/state_overview/#what-is-a-book","title":"What is a \"Book\"?","text":"<p>A \"book\" represents a single simulation result, storing: - The payout multiplier - Events triggered during the round - Win conditions</p> <p>Each simulation generates a book, which is stored in a library attached to the global GameState object.</p> <p>Example JSON structure: <pre><code>[\n    {\n        \"id\": int,\n        \"payoutMultiplier\": float,\n        \"events\": [ {}, {}, {} ],\n        \"criteria\": str,\n        \"baseGameWins\": float,\n        \"freeGameWins\": float\n    }\n]\n</code></pre></p> <p>At the start of a simulation, the book is reset: <pre><code>def reset_book(self) -&gt; None:\n    self.book = {\n        \"id\": self.sim + 1,\n        \"payoutMultiplier\": 0.0,\n        \"events\": [],\n        \"criteria\": self.criteria,\n    }\n</code></pre></p> <p>At the end of a round, if all win criteria are satisfied, the book is added to the library. For more details, see BetMode.</p>"},{"location":"source_section/board_info/","title":"Board","text":""},{"location":"source_section/board_info/#game-board","title":"Game Board","text":"<p>The <code>Board</code> class inherits the <code>GeneraGameState</code> class and handles the generation of game boards. Most commonly used is the <code>create_board_reelstrips()</code> function. Which selects a reelset as defined in the <code>BetMode.Distribution.conditions</code> class. For each reel a random stopping position is chosen with uniform probability on the range [0,len(reelstrip[reel])-1]. For each reelstop a 2D list of <code>Symbol</code> objects are created and attached to the GameState object. </p> <p>Additionally, special symbol information is included (special_symbols_on_board) along with the reelstop values (reel_positions), padding symbols directly above and below the active board (padding_positions) and which reelstip-id was used.</p> <p>The is also an anticipation field which is used for adding a delay to reel reveals if the number of Scatters required for trigging the freegame is almost satisfied. This is an array of values initialized to <code>0</code> and counting upwards in <code>+1</code> value increments. For example if 3 Scatter symbols are needed to trigger the freegame and there are Scatters revealed on reels 0 and 1, the array would take the form (for a 5 reel game): <pre><code>self.anticipation = [0, 0, 1, 2, 3]\n</code></pre></p> <p>If the selected reel_pos + the length of the board is greater than the total reelstrip length, the stopping position is wrapped around to the 0 index: <pre><code> self.reelstrip[reel][(reel_pos - 1) % len(self.reelstrip[reel])]\n</code></pre></p> <p>The reelset used is drawn from the weighted possible reelstrips as defined in the <code>BetMode.betmode.distributions.conditions</code> class (and hence is a required field in the <code>BetMode</code> object): <pre><code>    self.reelstrip_id = get_random_outcome(\n        self.get_current_distribution_conditions()[\"reel_weights\"][self.gametype]\n    )\n</code></pre></p> <p>Specific stopping positions can also be forced given a reelstip-id and integer stopping values from <code>force_board_from_reelstrips()</code>. If no integer value are provided for a reel, a random position is chosen. This function is typically used in conjunction with <code>executables.force_special_board</code>, which will search a reelstrip for a particular symbol name and randomly select a specified number of stopping positions, chosen to land on a randomly selected board row. </p> <p>Additionally the <code>Board</code> class handled symbol generation, displaying the current <code>.board</code> in the terminal, and retrieving symbol positions and properties as defined in <code>config.special_symbols</code>. </p>"},{"location":"source_section/event_info/","title":"Events Module Documentation","text":""},{"location":"source_section/event_info/#overview","title":"Overview","text":"<p>The <code>events.py</code> module defines reusable game events that modify the <code>gamestate</code> and log significant actions. These events ensure proper tracking of game states and facilitate structured client communication.</p>"},{"location":"source_section/event_info/#functions","title":"Functions","text":""},{"location":"source_section/event_info/#json_ready_symsymbol-special_attributes","title":"<code>json_ready_sym(symbol, special_attributes)</code>","text":"<p>Purpose: Converts a symbol object into a dictionary suitable for JSON serialization, including only specified attributes.</p> <p>Parameters: - <code>symbol (object)</code>: The symbol object to convert. - <code>special_attributes (list)</code>: A list of attribute names to include if they are not <code>False</code>.</p>"},{"location":"source_section/event_info/#reveal_eventgamestate","title":"<code>reveal_event(gamestate)</code>","text":"<p>Purpose: Logs the initial board state, including padding symbols if enabled.</p>"},{"location":"source_section/event_info/#fs_trigger_eventgamestate-include_padding_index-basegame_trigger-freegame_trigger","title":"<code>fs_trigger_event(gamestate, include_padding_index, basegame_trigger, freegame_trigger)</code>","text":"<p>Purpose: Logs the triggering of free spins, whether from the base game or a retrigger event.</p> <p>Assertions: - Either <code>basegame_trigger</code> or <code>freegame_trigger</code> must be <code>True</code>, not both. - <code>gamestate.tot_fs</code> must be greater than 0.</p>"},{"location":"source_section/event_info/#set_win_eventgamestate-winlevel_keystandard","title":"<code>set_win_event(gamestate, winlevel_key='standard')</code>","text":"<p>Purpose: Updates the cumulative win amount for a single outcome.</p>"},{"location":"source_section/event_info/#set_total_eventgamestate","title":"<code>set_total_event(gamestate)</code>","text":"<p>Purpose: Updates the total win amount for a betting round, including all free spins.</p>"},{"location":"source_section/event_info/#set_tumble_eventgamestate","title":"<code>set_tumble_event(gamestate)</code>","text":"<p>Purpose: Logs wins from consecutive tumbles.</p>"},{"location":"source_section/event_info/#wincap_eventgamestate","title":"<code>wincap_event(gamestate)</code>","text":"<p>Purpose: Emits an event when the maximum win amount is reached, stopping further spins.</p>"},{"location":"source_section/event_info/#win_info_eventgamestate-include_padding_indextrue","title":"<code>win_info_event(gamestate, include_padding_index=True)</code>","text":"<p>Purpose: Logs winning symbol positions and their win amounts, adjusting for padding if enabled.</p>"},{"location":"source_section/event_info/#update_tumble_win_eventgamestate","title":"<code>update_tumble_win_event(gamestate)</code>","text":"<p>Purpose: Updates the banner for tumble win amounts.</p>"},{"location":"source_section/event_info/#update_freespin_eventgamestate","title":"<code>update_freespin_event(gamestate)</code>","text":"<p>Purpose: Logs the current and total free spins remaining.</p>"},{"location":"source_section/event_info/#freespin_end_eventgamestate-winlevel_keyendfeature","title":"<code>freespin_end_event(gamestate, winlevel_key='endFeature')</code>","text":"<p>Purpose: Logs the end of a free spin feature and assigns the final win level.</p>"},{"location":"source_section/event_info/#final_win_eventgamestate","title":"<code>final_win_event(gamestate)</code>","text":"<p>Purpose: Logs the final payout multiplier at the end of a simulation.</p>"},{"location":"source_section/event_info/#update_global_mult_eventgamestate","title":"<code>update_global_mult_event(gamestate)</code>","text":"<p>Purpose: Logs changes to the global multiplier.</p>"},{"location":"source_section/event_info/#tumble_board_eventgamestate","title":"<code>tumble_board_event(gamestate)</code>","text":"<p>Purpose: Logs symbol positions removed during a tumble and their replacements.</p>"},{"location":"source_section/event_info/#usage-notes","title":"Usage Notes","text":"<ul> <li>Each function appends an event dictionary to <code>gamestate.book['events']</code>.</li> <li>Deep copies ensure that modifications do not affect past event states.</li> <li>Events provide structured output suitable for UI updates and analytics.</li> </ul> <p>This module is essential for maintaining a transparent, trackable game state across different game mechanics.</p>"},{"location":"source_section/executables_info/","title":"Executables Class Documentation","text":""},{"location":"source_section/executables_info/#overview","title":"Overview","text":"<p>The <code>Executables</code> class groups together common actions that are likely to be reused across multiple games. These functions can be overridden in <code>GameExecutables</code> or <code>GameCalculations</code> if game-specific alterations are required. Generally, <code>Executables</code> functions do not return values.</p>"},{"location":"source_section/executables_info/#function-descriptions","title":"Function Descriptions","text":""},{"location":"source_section/executables_info/#draw_boardemit_event-bool-true-none","title":"<code>draw_board(emit_event: bool = True) -&gt; None</code>","text":"<p>Forces the initial reveal to have a specific number of scatters if bet mode criteria specify it. Otherwise, it generates a new board and ensures it does not contain more scatters than necessary.</p>"},{"location":"source_section/executables_info/#force_special_boardforce_criteria-str-num_force_syms-int-none","title":"<code>force_special_board(force_criteria: str, num_force_syms: int) -&gt; None</code>","text":"<p>Forces a board to have a specified number of a particular symbol by modifying reel stops.</p>"},{"location":"source_section/executables_info/#get_syms_on_reelreel_id-str-target_symbol-str-listlist","title":"<code>get_syms_on_reel(reel_id: str, target_symbol: str) -&gt; List[List]</code>","text":"<p>Returns reel stop positions for a specific symbol name.</p>"},{"location":"source_section/executables_info/#emit_wayswin_events-none","title":"<code>emit_wayswin_events() -&gt; None</code>","text":"<p>Transmits win events associated with ways wins.</p>"},{"location":"source_section/executables_info/#emit_linewin_events-none","title":"<code>emit_linewin_events() -&gt; None</code>","text":"<p>Transmits win events associated with line wins.</p>"},{"location":"source_section/executables_info/#emit_tumble_win_events-none","title":"<code>emit_tumble_win_events() -&gt; None</code>","text":"<p>Transmits win and new board information upon a tumble event.</p>"},{"location":"source_section/executables_info/#tumble_game_board-none","title":"<code>tumble_game_board() -&gt; None</code>","text":"<p>Removes winning symbols from the active board and replaces them, triggering a tumble board event.</p>"},{"location":"source_section/executables_info/#evaluate_wincap-none","title":"<code>evaluate_wincap() -&gt; None</code>","text":"<p>Checks if the running bet win has reached the wincap limit and stops further spin functions if necessary.</p>"},{"location":"source_section/executables_info/#count_special_symbolsspecial_sym_criteria-str-int","title":"<code>count_special_symbols(special_sym_criteria: str) -&gt; int</code>","text":"<p>Returns the number of active symbols of a specified special kind.</p>"},{"location":"source_section/executables_info/#check_fs_conditionscatter_key-str-scatter-bool","title":"<code>check_fs_condition(scatter_key: str = \"scatter\") -&gt; bool</code>","text":"<p>Checks if there are enough active scatters to trigger free spins.</p>"},{"location":"source_section/executables_info/#check_freespin_entryscatter_key-str-scatter-bool","title":"<code>check_freespin_entry(scatter_key: str = \"scatter\") -&gt; bool</code>","text":"<p>Ensures that the bet mode criteria are expecting a free spin trigger before proceeding.</p>"},{"location":"source_section/executables_info/#run_freespin_from_basescatter_key-str-scatter-none","title":"<code>run_freespin_from_base(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Triggers the free spin function and updates the total number of free spins available.</p>"},{"location":"source_section/executables_info/#update_freespin_amountscatter_key-str-scatter-none","title":"<code>update_freespin_amount(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Sets the initial number of spins for a free game and transmits an event.</p>"},{"location":"source_section/executables_info/#update_fs_retrigger_amtscatter_key-str-scatter-none","title":"<code>update_fs_retrigger_amt(scatter_key: str = \"scatter\") -&gt; None</code>","text":"<p>Updates the total number of free spins available when a retrigger occurs.</p>"},{"location":"source_section/executables_info/#update_freespin-none","title":"<code>update_freespin() -&gt; None</code>","text":"<p>Called before a new reveal during free spins, resetting spin win data and other relevant attributes.</p>"},{"location":"source_section/executables_info/#end_freespin-none","title":"<code>end_freespin() -&gt; None</code>","text":"<p>Transmits the total amount awarded during the free spin session.</p>"},{"location":"source_section/executables_info/#evaluate_finalwin-none","title":"<code>evaluate_finalwin() -&gt; None</code>","text":"<p>Checks base and free spin sums, then sets the payout multiplier accordingly.</p>"},{"location":"source_section/executables_info/#update_global_mult-none","title":"<code>update_global_mult() -&gt; None</code>","text":"<p>Increments the multiplier value and emits the corresponding event.</p>"},{"location":"source_section/executables_info/#dependencies","title":"Dependencies","text":"<p>This class relies on multiple external modules, including: - <code>src.state.state_conditions.Conditions</code> - <code>src.calculations.lines.LineWins</code> - <code>src.calculations.cluster.ClusterWins</code> - <code>src.calculations.scatter.ScatterWins</code> - <code>src.calculations.ways.WaysWins</code> - <code>src.calculations.tumble.Tumble</code> - <code>src.calculations.statistics.get_random_outcome</code> - <code>src.events.events</code> (Various event handling functions)</p> <p>These modules provide necessary game logic, event management, and mathematical calculations for the execution of the class functions.</p>"},{"location":"source_section/executables_info/#usage","title":"Usage","text":"<p>This class is designed as a base class and is expected to be extended by game-specific implementations where needed. It ensures core game mechanics, such as board generation, free spin handling, and win event management, are handled in a reusable manner.</p>"},{"location":"source_section/lines_info/","title":"Line wins evaluation","text":"<p>The <code>LinesWins</code> object evaluates winning symbol combinations for the current <code>self.board</code> state. Generally 3 or more consecutive symbols result in a win, though these specific combination numbers and payouts can be defined in: <pre><code>config.paytable = {(kind[int], symbol[string]): payout[float]}\n</code></pre></p> <p>In order to identify winning lines, line arrays must be defined in: <pre><code>config.paylines = {\n    0: [0,0,0,0,0],\n    1: [0,1,0,1,0],\n        ...    \n    }\n</code></pre> in the <code>.paylines</code> dictionary, the key is the line-index and the value is an array dictating which rows result in a winning combination. Like symbols are matched and if the key <code>(kind, name)</code> exists in <code>self.paytable</code>, the corresponding win is evaluated. </p> <p>Custom keys used to identify wild attributes and symbol names can be explicitly set and will default to <code>\"wild\"</code> and <code>\"W\"</code> unless otherwise specified. In the case of <code>(kind, \"W\")</code> existing in <code>self.paytable</code>, the base payout value is checked against the <code>(kind, sym)</code> where sym is the first non-wild. If for example the payline <code>[0,0,0,0,0]</code> has the symbol combination <code>[W,W,W,L4,L4]</code>, resulting in wins <code>(3,\"W\")</code> or <code>(5,\"L4\")</code>. We compare both outcomes and determine that the three-kind Wild combination has a larger payout. Therefore we only take the first three symbols as the winning combination. Note that the sample lines calculation provided will only take into account the base-game wins. If the game is more complex, such as having multipliers on symbols, the final payout amount may need to be handled separately when deciding which winning combination to use. One common approach to dealing with this is to only define the Wild symbols to pay when there is a complete line (so only 5-kind Wilds would pay for a board of this size).</p> <p>The <code>get_lines()</code> evaluation function returns all win information including the winning symbol name, winning positions, number of consecutive matches and win amounts. The <code>meta</code> information also includes symbol and global multiplier information, as well as the index of winning lines as defined in `config.paylines = {index: [line], ... }. </p>"},{"location":"source_section/scatter_info/","title":"Scatter Pays","text":"<p>Scatter-pays (pay-anywhere) games award wins based on the total number of like-symbols appearing on the game board. Symbols do not have to be arranged in any order. Typically a minimum of 8 like-symbols (or Wilds) are required to count as a win, though these values can be defined in the <code>GameConfig</code> class. Since it is possible for up to <code>num_rows * num_columns</code> winning symbols to occur, it is common to define a particular payout range. For example <code>8-kind</code> pays <code>p1</code> <code>9-kind</code> to pay <code>p2</code>, <code>10-12</code> kind to pay <code>p3</code> and <code>12+</code> symbols pay <code>p4</code> etc... Instead of manually including all possible pay combinations in <code>config.paytable</code> there is a <code>convert_range_table()</code> function in the Config class which takes in a symbol range, name and payout amount which is used to generate all <code>config.paytable</code> entries. This pay group should be of the format: <pre><code>    paygroup = {\n        ((min_combination[int], max_combination[int]), name[str]) : payout[float],\n        ... \n    }\n</code></pre> Ranges defined in <code>min_combination</code> and <code>max_combination</code> are inclusive, so for example if the <code>8-kind</code> payout for symbol <code>H1</code> pays <code>10x</code>, this would be written as: <code>((8,8),H1): 10</code>.</p> <p>Often (though not always) Scatter pays games are also cascading/tumbling. Within the scatter sample game for example, while there are still winning combinations, the board is tumbled, wins are evaluated for the new board, the wallet manager is updated and relevent events are emitted: <pre><code>    while self.win_data[\"totalWin\"] &gt; 0 and not (self.wincap_triggered):\n        self.tumble_game_board()\n        self.win_data = self.get_scatterpay_wins(record_wins=True)\n        self.win_manager.update_spinwin(self.win_data[\"totalWin\"])\n        self.emit_tumble_win_events()\n</code></pre></p> <p>The Scatter pay evaluation function also checks for <code>multiplier</code> and <code>wild</code> attributes attached to symbols. Wild symbols can contribute to wins for any number of symbols. </p>"},{"location":"source_section/state_info/","title":"GeneralGameState Class Overview","text":""},{"location":"source_section/state_info/#class-generalgamestate","title":"Class: <code>GeneralGameState</code>","text":""},{"location":"source_section/state_info/#description","title":"Description:","text":"<p>The <code>GeneralGameState</code> class is an abstract base class (ABC) that defines the general structure for game states. Other game state classes inherit from it. It includes methods for initializing game configurations, resetting states, managing wins, and running simulations.</p>"},{"location":"source_section/state_info/#constructor","title":"Constructor:","text":""},{"location":"source_section/state_info/#__init__self-config","title":"<code>__init__(self, config)</code>","text":"<ul> <li>Initializes the game state with the provided configuration.</li> <li>Initializes variables like <code>library</code>, <code>recorded_events</code>, <code>special_symbol_functions</code>, <code>win_manager</code>, <code>criteria</code>, etc.</li> <li>Calls helper methods to reset seeds, create symbol mappings, reset book values, and assign special symbol functions.</li> </ul>"},{"location":"source_section/state_info/#methods","title":"Methods:","text":""},{"location":"source_section/state_info/#create_symbol_mapself-none","title":"<code>create_symbol_map(self) -&gt; None</code>","text":"<ul> <li>Extracts all valid symbols from the configuration.</li> <li>Constructs a <code>SymbolStorage</code> object containing all the symbols from the paytable and special symbols.</li> </ul>"},{"location":"source_section/state_info/#assign_special_sym_functionself-abstract-method","title":"<code>assign_special_sym_function(self)</code> (Abstract Method)","text":"<ul> <li>This method must be overridden in derived classes to define custom symbol behavior.</li> <li>Issues a warning if no special symbol functions are defined.</li> </ul>"},{"location":"source_section/state_info/#reset_bookself-none","title":"<code>reset_book(self) -&gt; None</code>","text":"<ul> <li>Resets global game state variables such as <code>board</code>, <code>book_id</code>, <code>book</code>, and <code>win_data</code>.</li> <li>Initializes default values for win tracking and spin conditions.</li> <li>Resets <code>win_manager</code> state.</li> </ul>"},{"location":"source_section/state_info/#reset_seedself-sim-int-0-none","title":"<code>reset_seed(self, sim: int = 0) -&gt; None</code>","text":"<ul> <li>Resets the random number generator seed based on the simulation number for reproducibility.</li> </ul>"},{"location":"source_section/state_info/#reset_fs_spinself-none","title":"<code>reset_fs_spin(self) -&gt; None</code>","text":"<ul> <li>Resets the free spin game state when triggered.</li> <li>Updates <code>gametype</code> and resets spin wins in <code>win_manager</code>.</li> </ul>"},{"location":"source_section/state_info/#get_betmodeself-mode_name-betmode","title":"<code>get_betmode(self, mode_name) -&gt; BetMode</code>","text":"<ul> <li>Retrieves a bet mode configuration based on its name.</li> <li>Prints a warning if the bet mode is not found.</li> </ul>"},{"location":"source_section/state_info/#get_current_betmodeself-object","title":"<code>get_current_betmode(self) -&gt; object</code>","text":"<ul> <li>Returns the current active bet mode.</li> </ul>"},{"location":"source_section/state_info/#get_current_betmode_distributionsself-object","title":"<code>get_current_betmode_distributions(self) -&gt; object</code>","text":"<ul> <li>Retrieves the distribution information for the current bet mode based on the active criteria.</li> <li>Raises an error if criteria distribution is not found.</li> </ul>"},{"location":"source_section/state_info/#get_current_distribution_conditionsself-dict","title":"<code>get_current_distribution_conditions(self) -&gt; dict</code>","text":"<ul> <li>Returns the conditions required for the current criteria setup.</li> <li>Raises an error if bet mode conditions are missing.</li> </ul>"},{"location":"source_section/state_info/#get_wincap_triggeredself-bool","title":"<code>get_wincap_triggered(self) -&gt; bool</code>","text":"<ul> <li>Checks if a max-win cap has been reached, stopping further spin progress if triggered.</li> </ul>"},{"location":"source_section/state_info/#in_criteriaself-args-bool","title":"<code>in_criteria(self, *args) -&gt; bool</code>","text":"<ul> <li>Checks if the current win criteria match any of the given arguments.</li> </ul>"},{"location":"source_section/state_info/#recordself-description-dict-none","title":"<code>record(self, description: dict) -&gt; None</code>","text":"<ul> <li>Records specific game events to the <code>temp_wins</code> list for tracking distributions.</li> </ul>"},{"location":"source_section/state_info/#check_force_keysself-description-none","title":"<code>check_force_keys(self, description) -&gt; None</code>","text":"<ul> <li>Verifies and adds unique force-key parameters to the bet mode configuration.</li> </ul>"},{"location":"source_section/state_info/#combineself-modes-betmode_name-none","title":"<code>combine(self, modes, betmode_name) -&gt; None</code>","text":"<ul> <li>Merges forced keys from multiple mode configurations into the target bet mode.</li> </ul>"},{"location":"source_section/state_info/#imprint_winsself-none","title":"<code>imprint_wins(self) -&gt; None</code>","text":"<ul> <li>Records triggered events in the <code>library</code> and updates <code>win_manager</code>.</li> </ul>"},{"location":"source_section/state_info/#update_final_winself-none","title":"<code>update_final_win(self) -&gt; None</code>","text":"<ul> <li>Computes and verifies the final win amount across base and free games.</li> <li>Ensures that total wins do not exceed the win cap.</li> <li>Raises an assertion error if the sum of base and free game payouts mismatches the recorded final payout.</li> </ul>"},{"location":"source_section/state_info/#check_repeatself-none","title":"<code>check_repeat(self) -&gt; None</code>","text":"<ul> <li>Determines if a spin needs to be repeated based on criteria constraints.</li> </ul>"},{"location":"source_section/state_info/#run_spinself-sim-abstract-method","title":"<code>run_spin(self, sim)</code> (Abstract Method)","text":"<ul> <li>Must be implemented in derived classes.</li> <li>Placeholder prints a message if not overridden.</li> </ul>"},{"location":"source_section/state_info/#run_freespinself-abstract-method","title":"<code>run_freespin(self)</code> (Abstract Method)","text":"<ul> <li>Must be implemented in derived classes.</li> <li>Placeholder prints a message if not overridden.</li> </ul>"},{"location":"source_section/state_info/#run_simsself-betmode_copy_list-betmode-sim_to_criteria-total_threads-total_repeats-num_sims-thread_index-repeat_count-compresstrue-write_event_listtrue-none","title":"<code>run_sims(self, betmode_copy_list, betmode, sim_to_criteria, total_threads, total_repeats, num_sims, thread_index, repeat_count, compress=True, write_event_list=True) -&gt; None</code>","text":"<ul> <li>Runs multiple simulations, setting up bet modes and criteria per simulation.</li> <li>Tracks and prints RTP calculations.</li> <li>Writes temporary JSON files for multi-threaded results.</li> <li>Generates lookup tables for criteria and payout distributions.</li> </ul>"},{"location":"source_section/state_info/#summary","title":"Summary","text":"<ul> <li><code>GeneralGameState</code> provides a foundation for defining and managing game states.</li> <li>It includes methods for configuring symbols, handling wins, recording events, and executing game simulations.</li> <li>Certain methods must be overridden in derived classes to customize behavior.</li> </ul>"},{"location":"source_section/tumble_info/","title":"Tumble","text":""},{"location":"source_section/tumble_info/#tumbling-boards","title":"Tumbling boards","text":"<p>The <code>Tumble</code> class inherits <code>Board</code> and handles removing winning symbols from <code>self.board</code> and filling vacant positions with symbols which appear directly above winning positions using the properties <code>reel_positions</code> and <code>reelstrip_id</code>. Examples of applications surrounding tumbling (cascading) events can be found in the <code>0_0_cluster</code> and <code>0_0_scatter</code> sample games. </p> <p>The win evaluation functions for the cluster and scatter win-types assign the property <code>explode = True</code> to winning symbol objects. A new board is select by scanning the current <code>self.board</code> object reel-by-reel and counting the number of symbols which satisfy <code>sym.check_attribute(\"explode\")</code>. This same number of symbols is then appended, counting backwards from the initial <code>self.reel_positions</code> values. If padding symbols are used, the symbol stored in <code>top_symbols</code> will be used to fill the first vacated position. </p>"},{"location":"source_section/ways_info/","title":"Ways wins evaluation","text":"<p>The <code>WaysWins</code> object evaluates winning symbol combinations for the current <code>self.board</code> state. Generally 3 or more consecutive symbols result in a win, though these specific combination numbers and payouts can be defined in: <pre><code>config.paytable = {(kind[int], symbol[string]): payout[float]}\n</code></pre></p> <p>The ways calculation will search for like-symbols (or Wilds) on consecutive reels. The maximum number of ways is determined from the board size: <code>max_ways = (num_rows)^(num_columns)</code>.  Note: the ways calculation does not account for Wild symbols appearing on the first reel. </p> <p>The Ways evaluation takes also takes into account multiplier values attached to symbols containing the <code>multiplier</code> attribute. Unlike lines calculations where multiplier values are added together for symbols on consecutive reels, the total number of ways is instead multiplied by the multiplier value. Leading to the payout amount to grow substancially more quickly. So for example given the board: <pre><code>L5 H1 L4 L4 L4 \nL1 H4 L3 H2 L4 \nH1 H1 H1 L3 H3 \n</code></pre> If there is a multiplier value of, say 3x on the <code>H1</code> symbol on reel 3, the total ways for symbol <code>H1</code> is <code>(3,H1)</code> pays: <pre><code>(1) * (2) * (3) = 6 ways\n</code></pre></p> <p>The <code>return_data</code> will include all winning symbol names, number of consecutive like-symbols, winning positions and total win amounts for each unique symbol type. the <code>meta</code> tag will additionally include the total number of ways a symbol wins, which will range from <code>1</code> to <code>(num_rows)^(num_columns)</code> and and additional symbol and/or global multiplier contributions.</p>"}]}